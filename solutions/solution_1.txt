📂 BÖLÜM 1: INDEX
Sorun 1 — JSONP ile API çağrısı (callback + <script> enjeksiyonu)
🏆 Üstün Çözüm: fetch + JSON + CORS ile tek sözleşmeli çağrı katmanı. Nasıl Yapılır:
	1	apiCall fonksiyonunu fetch(URLSearchParams) ile yeniden yaz.
	2	HTTP hata yönetimini if (!res.ok) throw Error(...) şeklinde standardize et.
	3	Tüm çağıran yerlerde eski JSONP akışını kaldır ve yeni apiCall’a geçir. Mevcut Koda Etkisi:
	•	Güvenlik: ▲▲ (JSONP kaynaklı riskler kapanır)
	•	Modernizasyon: ▲▲ (standart web API, test edilebilirlik)
	•	Performans: ▲ (daha az DOM/script ekleme)
	•	Bakım/Okunabilirlik: ▲▲ (tek sözleşme, merkezi hata yönetimi)
	•	Kod Yapısı Riski: ◼︎ Orta (çağıranların toplu güncellenmesi)

Sorun 2 — innerHTML ile metin/yapı yazımı (XSS yüzeyi)
🏆 Üstün Çözüm: Güvenli UI yardımcıları (textContent tabanlı) + gerekiyorsa sınırlı DOMPurify. Nasıl Yapılır:
	1	UI.alertSafe(message, type) ve basit renderListSafe(items) yardımcıları yaz.
	2	Tüm innerHTML = ... kullanımını bu yardımcılarla değiştir; metinler textContent olarak set edilsin.
	3	Sadece gerçekten gerekli yerlerde, beyaz liste ile DOMPurify kullan. Mevcut Koda Etkisi:
	•	Güvenlik: ▲▲▲ (XSS yüzeyi kapanır)
	•	Modernizasyon: ▲ (UI yardımcıları)
	•	Performans: ■ Nötr (çoğunlukla aynı)
	•	Bakım/Okunabilirlik: ▲▲ (tekrarlı şablonlar kalkar)
	•	Kod Yapısı Riski: ◼︎ Düşük

Sorun 3 — ICS dosyasını front-end’te üretme (TZ/format dağınık)
🏆 Üstün Çözüm: ICS üretimini Apps Script’e taşı; front sadece indirir. TZ: Europe/Istanbul. Nasıl Yapılır:
	1	Backend’de generateICS(event) ve action=getICS ekle.
	2	Front: fetch('...action=getICS') → Blob → download.
	3	ICS alanları: DTSTART/DTEND;TZID=Europe/Istanbul, UID, DTSTAMP. Mevcut Koda Etkisi:
	•	Güvenlik: ■ Nötr
	•	Modernizasyon: ▲ (tek kaynak, tutarlı format)
	•	Performans: ▲ (front daha az hesaplama/şablon)
	•	Bakım/Okunabilirlik: ▲▲ (kopya kod kalkar)
	•	Kod Yapısı Riski: ◼︎ Düşük

Sorun 4 — Ortama bağlı sabitlerin koda gömülü olması (URL vb.)
🏆 Üstün Çözüm: env.js (gitignore) + config.js (genel) ile yapılandırma dışsallaştırma. Nasıl Yapılır:
	1	env.js içinde window.ENV = { APPS_SCRIPT_URL: "..." }.
	2	config.js → const CONFIG = { APPS_SCRIPT_URL: window.ENV.APPS_SCRIPT_URL, TIMEZONE:'Europe/Istanbul' }.
	3	HTML’de her sayfaya önce env.js, sonra config.js yükle. Mevcut Koda Etkisi:
	•	Güvenlik: ▲ (gizli/değişken bilgi repodan çıkar)
	•	Modernizasyon: ▲▲ (ortam yönetimi)
	•	Performans: ■ Nötr
	•	Bakım/Okunabilirlik: ▲▲ (staging/prod geçişi kolay)
	•	Kod Yapısı Riski: ◼︎ Düşük

Sorun 5 — UA bazlı platform tespiti (kırılgan akış)
🏆 Üstün Çözüm: Özellik tespiti (feature detection) ile akış seçimi. Nasıl Yapılır:
	1	supportsDownload(), supportsWebShare(), supportsWebcal() gibi yardımcı fonksiyonlar.
	2	İndirme / paylaşma / webcal yollarını bu fonksiyonların sonuçlarına göre seç. Mevcut Koda Etkisi:
	•	Güvenlik: ■ Nötr
	•	Modernizasyon: ▲ (kalıcı çözüm)
	•	Performans: ■ Nötr
	•	Bakım/Okunabilirlik: ▲ (daha az “if UA.includes…”)
	•	Kod Yapısı Riski: ◼︎ Düşük

📂 BÖLÜM 2: ADMIN
Sorun 1 — Admin’de de JSONP kullanımı
🏆 Üstün Çözüm: Ortak apiCall (fetch+JSON) modülünü admin’de de kullan. Nasıl Yapılır:
	1	src/shared/api.js (tek) dosyasını oluştur.
	2	Admin tarafındaki tüm API çağrılarını bu modüle geçir. Mevcut Koda Etkisi:
	•	Güvenlik: ▲▲ (JSONP kalkar)
	•	Modernizasyon: ▲▲
	•	Performans: ▲
	•	Bakım/Okunabilirlik: ▲▲ (tek yerden yönetim)
	•	Kod Yapısı Riski: ◼︎ Orta (birçok çağrı değişecek)

Sorun 2 — Admin aksiyonlarında yetkilendirme eksikliği
🏆 Üstün Çözüm: Sunucu tarafında ADMIN_API_KEY kontrolü (kısa vadede). Nasıl Yapılır:
	1	Apps Script ScriptProperties → ADMIN_API_KEY sakla.
	2	Admin’den gönderilen tüm “yönetim” isteklerine apiKey ekle.
	3	Backend’de requireAdmin(e) guard: geçersiz anahtarda 401/403 JSON. Mevcut Koda Etkisi:
	•	Güvenlik: ▲▲▲ (kritik)
	•	Modernizasyon: ▲ (standart auth deseni)
	•	Performans: ■ Nötr
	•	Bakım/Okunabilirlik: ▲ (net sorumluluk)
	•	Kod Yapısı Riski: ◼︎ Düşük–Orta (istek imzalama eklenir)

Sorun 3 — innerHTML tabanlı bildirimler / listelemeler
🏆 Üstün Çözüm: Index’teki UI.alertSafe ve güvenli render yardımcılarını ortaklaştır. Nasıl Yapılır:
	1	src/shared/ui.js oluştur: alertSafe, renderListSafe.
	2	Admin’deki innerHTML kullanan noktaları bu yardımcılarla değiştir. Mevcut Koda Etkisi:
	•	Güvenlik: ▲▲
	•	Modernizasyon: ▲
	•	Performans: ■ Nötr
	•	Bakım/Okunabilirlik: ▲▲
	•	Kod Yapısı Riski: ◼︎ Düşük

Sorun 4 — document.execCommand('copy') (deprecated)
🏆 Üstün Çözüm: Asenkron Clipboard API (navigator.clipboard.writeText). Nasıl Yapılır:
	1	copyText(text) yardımcı fonksiyonu ekle.
	2	Tüm “Kopyala” butonları bu yardımcıyı kullansın. Mevcut Koda Etkisi:
	•	Güvenlik: ▲ (izinli, tarayıcı modern API)
	•	Modernizasyon: ▲▲
	•	Performans: ■ Nötr
	•	Bakım/Okunabilirlik: ▲ (tek yardımcı)
	•	Kod Yapısı Riski: ◼︎ Düşük (HTTPS gerekliliğine dikkat)

Sorun 5 — Tarih/hafta hesaplarının tekrarlı ve kırılgan olması
🏆 Üstün Çözüm: utils/datetime.js altında ISO hafta ve hafta başlangıcı yardımcıları. Nasıl Yapılır:
	1	getWeekStart(date), getISOWeek(date) fonksiyonlarını yaz.
	2	Tüm manuel hesapları bu fonksiyonlara yönlendir. Mevcut Koda Etkisi:
	•	Güvenlik: ■ Nötr
	•	Modernizasyon: ▲
	•	Performans: ▲ (daha az karmaşa/hata)
	•	Bakım/Okunabilirlik: ▲▲ (tek kaynak)
	•	Kod Yapısı Riski: ◼︎ Düşük

📂 BÖLÜM 3: APPS SCRIPT (Backend)
Sorun 1 — JSONP/callback ile yanıt üretimi
🏆 Üstün Çözüm: doGet/doPost → JSON yanıt + CORS başlıkları; JSONP kaldır. Nasıl Yapılır:
	1	callback parametresi desteğini kaldır.
	2	handleRequest(e, method) tek noktadan JSON döndürsün (ContentService + CORS).
	3	Hata yakalama: { success:false, error:"..." } şeması. Mevcut Koda Etkisi:
	•	Güvenlik: ▲▲
	•	Modernizasyon: ▲▲
	•	Performans: ▲ (daha az metin birleştirme)
	•	Bakım/Okunabilirlik: ▲▲ (tek yanıt katmanı)
	•	Kod Yapısı Riski: ◼︎ Orta (front önce güncellenmeli)

Sorun 2 — Admin aksiyonlarında sunucu tarafı yetki kontrolü yok
🏆 Üstün Çözüm: requireAdmin(e) guard + ADMIN_ACTIONS kümesi + 401/403. Nasıl Yapılır:
	1	ADMIN_ACTIONS = new Set([...]) (add/remove/toggle/save).
	2	requireAdmin: if (ADMIN_ACTIONS.has(action) && e.parameter.apiKey !== ADMIN_API_KEY) throw...
	3	Hataları JSON olarak döndür. Mevcut Koda Etkisi:
	•	Güvenlik: ▲▲▲
	•	Modernizasyon: ▲
	•	Performans: ■ Nötr
	•	Bakım/Okunabilirlik: ▲
	•	Kod Yapısı Riski: ◼︎ Düşük

Sorun 3 — ICS/e-posta şablonları ve randevu tipleri dağınık
🏆 Üstün Çözüm: Tek enum+şablon kaynağı (örn. APPOINTMENT_TYPES, DISPLAY_NAMES, TEMPLATES). Nasıl Yapılır:
	1	const APPOINTMENT_TYPES = {...} ve const DISPLAY_NAMES = {...} oluştur.
	2	sendCustomerMail(), notifyStaffAndAdmin() yardımcılarıyla e-posta/ICS metinlerini merkezileştir. Mevcut Koda Etkisi:
	•	Güvenlik: ■ Nötr
	•	Modernizasyon: ▲ (tek yerden değiştirilebilir)
	•	Performans: ▲ (daha az tekrar/şablon üretimi)
	•	Bakım/Okunabilirlik: ▲▲ (tutarlılık)
	•	Kod Yapısı Riski: ◼︎ Düşük–Orta (metinlerde ufak uyarlamalar)

Sorun 4 — Sık erişilen veriler için kalıcılık/cache yok
🏆 Üstün Çözüm: Basit kalıcı cache (PropertiesService + TTL) yardımcı sınıfı. Nasıl Yapılır:
	1	PersistentCache.get(key, loader, ttlSecs) yaz.
	2	Personel listesi/ayarlar gibi sık okunan yerlere uygula. Mevcut Koda Etkisi:
	•	Güvenlik: ■ Nötr
	•	Modernizasyon: ▲
	•	Performans: ▲▲ (uzak okuma maliyeti düşer)
	•	Bakım/Okunabilirlik: ▲ (tek desen)
	•	Kod Yapısı Riski: ◼︎ Düşük (TTL yanlışsa stale riski—kısa TTL ile başla)

🧩 Tüm Sorunların Tüm Çözümlerle Bütün Koda Etkisi (Özet)
	•	Güvenlik: Çok Yüksek artış
	◦	JSONP’nin kaldırılması, XSS yüzeylerinin kapatılması ve admin için server-side yetki kontrolü kritik açıkları kapatır.
	•	Modernizasyon: Yüksek artış
	◦	fetch/CORS, Clipboard API, config dışsallaştırma, ortak modüller (api/ui/datetime) ile kod tabanı güncel web standartlarına taşınır.
	•	Performans: Orta artış
	◦	JSONP’nin ve gereksiz DOM işlemlerinin kalkması, ICS’nin backend’e taşınması ve kalıcı cache ile gözle görülür iyileşme.
	•	Bakım/Okunabilirlik: Çok Yüksek artış
	◦	Tek sözleşmeli API, tek kaynaklı ICS/şablonlar, yardımcı modüller ve ortam ayrımı, değişikliklerin etkisini lokalize eder.
	•	Kod Yapısı Riski (Geçiş Riski): Düşük–Orta (yönetilebilir)
	◦	En büyük kırılım, önce frontların fetch sözleşmesine geçirilmesi, ardından backend’in JSONP’yi kapatmasıyla yönetilir.
	◦	Öneri: Sprint sırası → (1) Front fetch + XSS temizlik → (2) Backend CORS/JSON → (3) ICS/şablon konsolidasyonu → (4) Cache + yardımcılar.


——————————

🧭 Sprint 1 — Güvenlik & Altyapı (JSONP → fetch, XSS, Admin Auth)
🎫 Kart 1.1 — JSONP’yi Kaldır, fetch + JSON + CORS’a Geç (Index + Admin)
Amaç: Tek sözleşmeli, güvenli ve test edilebilir çağrı katmanı.
Etkilenen dosyalar
	•	/mnt/data/index.html (tüm API çağrı yerleri)
	•	/mnt/data/admin.html (tüm API çağrı yerleri)
	•	yeni: src/shared/api.js (tek modül)
	•	/mnt/data/apps-script-backend.js (CORS başlıkları + JSON yanıt standardı)
Önerilen diff (iskelet)

--- a/index.html
+++ b/index.html
@@
- <!-- Eski: JSONP script injection ve callback adı üretimi -->
- <script>/* apiCall via JSONP ... */</script>
+ <!-- Yeni: ortak API modülü -->
+ <script src="config.js"></script>
+ <script src="src/shared/api.js"></script>

--- a/admin.html
+++ b/admin.html
@@
- <script>/* admin JSONP apiCall */</script>
+ <script src="config.js"></script>
+ <script src="src/shared/api.js"></script>
+ <script>
+  // örnek kullanım
+  api.get('listStaff').then(renderStaff)
+                     .catch(err => UI.alertSafe(err.message, 'error'));
+ </script>
Kod (src/shared/api.js)

// src/shared/api.js
const api = {
  async get(action, params = {}) {
    const url = new URL(CONFIG.APPS_SCRIPT_URL);
    url.searchParams.set('action', action);
    for (const [k, v] of Object.entries(params)) url.searchParams.set(k, v);
    const res = await fetch(url.toString(), { credentials: 'omit' });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const ct = res.headers.get('content-type') || '';
    return ct.includes('application/json') ? res.json() : res.text();
  },
  async post(action, body = {}) {
    const url = new URL(CONFIG.APPS_SCRIPT_URL);
    url.searchParams.set('action', action);
    const res = await fetch(url.toString(), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
      credentials: 'omit'
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }
};
window.api = api;
Backend patch (CORS + JSON standardı)

--- a/apps-script-backend.js
+++ b/apps-script-backend.js
@@
-function doGet(e){ /* JSONP callback mantığı ... */ }
+function doGet(e){ return handleRequest(e, 'GET'); }
+function doPost(e){ return handleRequest(e, 'POST'); }
+
+function handleRequest(e, method){
+  try{
+    const payload = route(e, method);
+    return jsonOk(payload);
+  }catch(err){
+    return jsonOk({ success:false, error: String(err) }, 200);
+  }
+}
+
+function jsonOk(obj, status=200){
+  const out = ContentService.createTextOutput(JSON.stringify(obj))
+      .setMimeType(ContentService.MimeType.JSON);
+  out.setHeader('Access-Control-Allow-Origin','*');
+  out.setHeader('Access-Control-Allow-Methods','GET, POST, OPTIONS');
+  out.setHeader('Access-Control-Allow-Headers','Content-Type');
+  return out;
+}
PR Taslağı
	•	Başlık: feat(api): JSONP’yi kaldır, fetch+JSON sözleşmesine geç
	•	Özet: Front’ta ortak api.js; backend’de handleRequest + CORS; tüm çağrılar yeni sözleşmeye geçirildi.
	•	Test Planı: 200/4xx/5xx dönüşleri; ağ kesintisi simülasyonu; admin ve index akışlarının tümü.
	•	Rollback: api.js import’u ve handleRequest çağrıları geri alınır; JSONP kodu restore.

🎫 Kart 1.2 — XSS Önleme: innerHTML → Güvenli UI Yardımcıları
Amaç: Kullanıcı girdisi kaynaklı XSS yüzeyini kapatmak.
Etkilenen dosyalar
	•	/mnt/data/index.html
	•	/mnt/data/admin.html
	•	yeni: src/shared/ui.js
Önerilen diff

--- a/index.html
+++ b/index.html
@@
- container.innerHTML = "<div class='alert'>" + msg + "</div>";
+ UI.alertSafe(msg, 'info');

--- a/admin.html
+++ b/admin.html
@@
- listEl.innerHTML = items.map(x => `<li>${x.name}</li>`).join('');
+ UI.renderListSafe(listEl, items.map(x => x.name));
Kod (src/shared/ui.js)

// src/shared/ui.js
const UI = {
  alertSafe(message, type='info') {
    const c = document.getElementById('alertContainer') || document.body;
    const box = document.createElement('div');
    box.className = `alert alert-${type}`;
    box.textContent = String(message ?? '');
    c.appendChild(box);
    setTimeout(()=> box.remove(), 4000);
  },
  renderListSafe(ul, texts=[]) {
    ul.textContent = '';
    for (const t of texts){
      const li = document.createElement('li');
      li.textContent = String(t ?? '');
      ul.appendChild(li);
    }
  }
};
window.UI = UI;
PR Taslağı
	•	Başlık: fix(xss): innerHTML kullanımını güvenli yardımcılarla değiştir
	•	Özet: alertSafe, renderListSafe eklendi; yüzeysel XSS noktaları temizlendi.
	•	Test Planı: <img onerror=alert(1)>, <script> payload’ları etkisiz.
	•	Rollback: UI yardımcıları devre dışı; önceki innerHTML satırları geri alınır.

🎫 Kart 1.3 — Admin Yetkilendirme (API Key, kısa vade)
Amaç: Yönetim aksiyonlarını yetkisiz kullanıma kapatmak.
Etkilenen dosyalar
	•	/mnt/data/apps-script-backend.js
	•	/mnt/data/admin.html (isteklere apiKey ekleme)
Backend patch

--- a/apps-script-backend.js
+++ b/apps-script-backend.js
@@
+const ADMIN_ACTIONS = new Set(['addStaff','removeStaff','toggleStaff','saveShifts','saveSettings']);
+const ADMIN_API_KEY = PropertiesService.getScriptProperties().getProperty('ADMIN_API_KEY');
+
+function requireAdmin(e){
+  const action = e.parameter.action;
+  if (ADMIN_ACTIONS.has(action)){
+    if (e.parameter.apiKey !== ADMIN_API_KEY) throw new Error('Unauthorized');
+  }
+}
 
 function handleRequest(e, method){
   try{
+    requireAdmin(e);
     const payload = route(e, method);
     return jsonOk(payload);
   }catch(err){
     return jsonOk({ success:false, error: String(err) }, 200);
   }
 }
Admin tarafı (örnek çağrı)

// admin.html (kullanım)
api.post('saveSettings', { ... , apiKey: CONFIG.ADMIN_API_KEY })
   .then(()=> UI.alertSafe('Ayarlar kaydedildi','success'))
   .catch(err => UI.alertSafe(err.message,'error'));
PR Taslağı
	•	Başlık: feat(admin-auth): yönetim aksiyonları için API key kontrolü
	•	Özet: requireAdmin guard; ScriptProperties’te ADMIN_API_KEY.
	•	Test Planı: key’siz istek 401/403; doğru anahtarda başarı.
	•	Rollback: requireAdmin çağrısı ve kontrol satırları geri alınır.

🧭 Sprint 2 — Mimari Temizlik (ICS tek kaynak, Config dışsallaştırma)
🎫 Kart 2.1 — ICS Üretimini Backend’e Taşı (Index/Admin indirsin)
Amaç: Tek kaynaktan doğru ICS; kopya kod temizliği.
Etkilenen dosyalar
	•	/mnt/data/apps-script-backend.js (yeni endpoint)
	•	/mnt/data/index.html (indirme akışı)
	•	/mnt/data/admin.html (gerekliyse indirme akışı)
Backend: ICS endpoint

--- a/apps-script-backend.js
+++ b/apps-script-backend.js
@@
+function route(e, method){
+  const action = e.parameter.action;
+  if (action === 'getICS') return { ics: generateICS(extractEvent(e)) };
+  // ...diğer actionlar...
+}
+
+function generateICS(evt){
+  const lines = [
+    'BEGIN:VCALENDAR','VERSION:2.0','CALSCALE:GREGORIAN',
+    'BEGIN:VEVENT',
+    `UID:${evt.uid}`,
+    `DTSTAMP:${evt.dtstamp}Z`,
+    `DTSTART;TZID=Europe/Istanbul:${evt.dtstart}`,
+    `DTEND;TZID=Europe/Istanbul:${evt.dtend}`,
+    `SUMMARY:${evt.summary}`,
+    `DESCRIPTION:${evt.description}`,
+    'END:VEVENT','END:VCALENDAR'
+  ];
+  return lines.join('\r\n');
+}
Frontend: indirme akışı

// index.html
async function downloadICS(params){
  const { ics } = await api.get('getICS', params);
  const blob = new Blob([ics], { type: 'text/calendar;charset=utf-8' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'event.ics';
  document.body.appendChild(a); a.click(); a.remove();
}
PR Taslağı
	•	Başlık: refactor(ics): ICS üretimini backend’e taşı, front yalnız indir
	•	Özet: getICS action; TZ Europe/Istanbul; front’ta blob indirme.
	•	Test Planı: iOS/Android/Outlook/GCal’da saat doğruluğu.
	•	Rollback: generateICS ve getICS kaldırılır; eski front şablonu geri.

🎫 Kart 2.2 — Konfigürasyon Dışsallaştırma (env.js + config.js)
Amaç: Ortam bazlı değerler repo dışına.
Etkilenen dosyalar
	•	yeni: env.js (gitignore)
	•	yeni: config.js
	•	/mnt/data/index.html, /mnt/data/admin.html (script ekleme)
Dosyalar

// env.js (gitignore)
window.ENV = {
  APPS_SCRIPT_URL: "https://script.google.com/macros/s/XXXX/exec",
  ADMIN_API_KEY: "set-me-on-deploy"
};

// config.js
const CONFIG = {
  APPS_SCRIPT_URL: window.ENV.APPS_SCRIPT_URL,
  ADMIN_API_KEY: window.ENV.ADMIN_API_KEY,
  TIMEZONE: 'Europe/Istanbul'
};
PR Taslağı
	•	Başlık: chore(config): env.js + config.js ile ortam yönetimi
	•	Özet: URL/anahtarlar koddan çıktı; staging/prod kolaylaştı.
	•	Test Planı: env değişimiyle sıfır kod değişiklik.
	•	Rollback: script ekleri ve CONFIG kullanımı geri alınır.

🧭 Sprint 3 — UX/DX Modernizasyonu
🎫 Kart 3.1 — Clipboard API’ye Geçiş
Amaç: execCommand('copy') yerine modern API.
Etkilenen dosyalar
	•	/mnt/data/admin.html
	•	yeni/ortak: src/shared/ui.js (kopyalama yardımcısi)
Kod

--- a/src/shared/ui.js
+++ b/src/shared/ui.js
@@
+UI.copyText = async function(text){
+  try{
+    await navigator.clipboard.writeText(String(text ?? ''));
+    UI.alertSafe('Kopyalandı','success');
+  }catch{
+    UI.alertSafe('Kopyalanamadı','error');
+  }
+};
PR Taslağı
	•	Başlık: feat(clipboard): execCommand yerine Clipboard API
	•	Özet: Tüm kopyalama butonları UI.copyText kullanıyor.
	•	Test Planı: HTTPS ortamında kopyalama başarılı.
	•	Rollback: UI.copyText yerine eski fonksiyonlar restore.

🎫 Kart 3.2 — Feature Detection ile Akış Seçimi (UA Parsingi Kaldır)
Amaç: Dayanıklı platform davranışı.
Etkilenen dosyalar
	•	/mnt/data/index.html (download/share/webcal akışı)
	•	yeni: src/shared/features.js
Kod (src/shared/features.js)

const Features = {
  supportsDownload(){ try{ return 'download' in document.createElement('a'); }catch{ return false; } },
  supportsShare(){ return !!(navigator.share); },
  supportsClipboard(){ return !!(navigator.clipboard && navigator.clipboard.writeText); },
  // webcal desteği tarayıcıya göre değişir; iOS Safari için tespit akışı:
  isLikelyIOS(){ return /iPad|iPhone|iPod/.test(navigator.userAgent); }
};
window.Features = Features;
PR Taslağı
	•	Başlık: refactor(feature-detect): UA yerine özellik tespiti
	•	Özet: İndirme/paylaşım/webcal kararları özellik bazlı.
	•	Test Planı: iOS Safari / Android Chrome / Desktop tarayıcıları.
	•	Rollback: çağrılar eski koşullara alınır.

🎫 Kart 3.3 — Tarih/Hafta Yardımcıları (ISO Week)
Amaç: Tekrarlı, kırılgan tarih hesaplarını merkezileştir.
Etkilenen dosyalar
	•	/mnt/data/admin.html
	•	yeni: src/shared/datetime.js
Kod (src/shared/datetime.js)

export function getWeekStart(d){
  const tmp = new Date(d); const day = tmp.getDay() || 7;
  if(day !== 1) tmp.setDate(tmp.getDate() - (day - 1));
  return new Date(tmp.getFullYear(), tmp.getMonth(), tmp.getDate());
}
export function getISOWeek(d){
  const tmp = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  const dayNum = tmp.getUTCDay() || 7; tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(), 0, 1));
  return Math.ceil((((tmp - yearStart) / 86400000) + 1) / 7);
}
PR Taslağı
	•	Başlık: refactor(datetime): ISO hafta/hafta başı yardımcıları
	•	Özet: Tüm manuel hesaplar datetime.js’e taşındı.
	•	Test Planı: 1/52/53. haftalar için örnek veri doğrulama.
	•	Rollback: fonksiyon referansları eski hesaplamalara dönülür.

🧭 Sprint 4 — Verimlilik & İçerik Konsolidasyonu
🎫 Kart 4.1 — Basit Kalıcı Cache (PropertiesService + TTL)
Amaç: Sık okunan verilerde gecikme/maliyet düşürmek.
Etkilenen dosyalar
	•	/mnt/data/apps-script-backend.js (cache sınıfı + kullanım noktaları)
Kod (Apps Script)

function PersistentCache(ttlSecs){ this.ttl = ttlSecs || 300; }
PersistentCache.prototype.get = function(key, loader){
  const ps = PropertiesService.getScriptProperties();
  const meta = JSON.parse(ps.getProperty('__CACHE_META__') || '{}');
  const now = Date.now();
  if (meta[key] && meta[key].exp > now) {
    return JSON.parse(ps.getProperty(`CACHE_${key}`));
  }
  const val = loader();
  ps.setProperty(`CACHE_${key}`, JSON.stringify(val));
  meta[key] = { exp: now + this.ttl*1000 };
  ps.setProperty('__CACHE_META__', JSON.stringify(meta));
  return val;
};
Kullanım örneği

const cache = new PersistentCache(300);
function getStaffList(){
  return cache.get('staff', () => {
    // pahalı okuma...
    return readStaffFromSheet();
  });
}
PR Taslağı
	•	Başlık: feat(cache): PropertiesService tabanlı TTL cache
	•	Özet: Staff/ayar okuma maliyeti düşer, 2. çağrılar hızlanır.
	•	Test Planı: İlk/ikinci çağrı latency kıyas, TTL sonrası yenileme.
	•	Rollback: cache sınıfı ve çağrıları kaldırılır, doğrudan okuma.

🎫 Kart 4.2 — E-posta/ICS Şablon Konsolidasyonu
Amaç: Tek enum/şablon kaynağı; tutarlı metinler.
Etkilenen dosyalar
	•	/mnt/data/apps-script-backend.js (şablon modülü + kullanım)
Kod

const APPOINTMENT_TYPES = { consultation:'consultation', meeting:'meeting' };
const DISPLAY_NAMES = { consultation:'Danışmanlık', meeting:'Toplantı' };
const TEMPLATES = {
  customerSubject: (t)=> `Randevu: ${DISPLAY_NAMES[t]}`,
  customerBody: (evt)=> `Merhaba...\nTarih: ${evt.date}\nSaat: ${evt.time}\n...`,
  staffBody: (evt)=> `Yeni etkinlik: ${evt.summary}\n...`
};

function sendCustomerMail(evt){
  const subject = TEMPLATES.customerSubject(evt.type);
  const body = TEMPLATES.customerBody(evt);
  // MailApp.sendEmail(...subject, body...)
}
PR Taslağı
	•	Başlık: refactor(templates): e-posta/ICS metinleri tek modülde
	•	Özet: Adlandırmalar ve metinler tek yerden yönetiliyor.
	•	Test Planı: Her randevu tipinde doğru konu/gövde; alan uyuşmazlığı yok.
	•	Rollback: tek modül kaldırılıp önceki metinler restore edilir.

🧩 Tüm Sorunların Tüm Çözümlerle Bütün Koda Etkisi (Toplam Etki Özeti)
	•	Güvenlik: Çok yüksek artış
	◦	JSONP’nin kaldırılması, XSS yüzeyinin kapanması, admin aksiyonlarının yetkilendirilmesi.
	•	Modernizasyon: Yüksek artış
	◦	fetch/CORS, Clipboard API, feature detection, env/config ayrımı, ortak modüller (api/ui/datetime).
	•	Performans: Orta+ artış
	◦	Script enjeksiyonunun kalkması, ICS’nin backend’e taşınması, persistent cache ile sıcak çağrılarda hızlanma.
	•	Bakım/Okunabilirlik: Çok yüksek artış
	◦	Tek sözleşme, tek şablon/ICS kaynağı, yardımcı modüller ve ortam yönetimi sayesinde değişiklikler lokalize.
	•	Kod Yapısı Riski (Geçiş): Düşük–Orta, yönetilebilir
	◦	En kritik bağımlılık: front’lar önce api.js’e geçirilir → backend JSONP kaldırılır → ICS/şablonlar konsolide edilir → cache/yardımcılar devreye alınır.
